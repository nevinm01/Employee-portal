import { slicedToArray as _slicedToArray, createClass as _createClass, classCallCheck as _classCallCheck } from '../_virtual/_rollupPluginBabelHelpers.js';
import React, { useState } from 'react';
import { Debug } from '../debug.js';
import { InformedContext } from '../Context.js';

var debug = Debug('informed:Informed' + '\t\t');

/* -------------------------------- Event Emitter ------------------------------ */
var Emitter = /*#__PURE__*/function () {
  function Emitter() {
    _classCallCheck(this, Emitter);
    // Initialize listeners
    this.subscriptions = new Map();

    // This is the emitter lol
    this.emitter = this;

    // Bind functions that will be called externally
    this.on = this.on.bind(this);
    this.emit = this.emit.bind(this);
  }
  _createClass(Emitter, [{
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      // Grab the set based on the event
      var listeners = this.subscriptions.get(event);
      // Only call if we have listeners on that event ( null check )
      if (listeners) {
        listeners.forEach(function (listener) {
          return listener.apply(void 0, args);
        });
      }
    }
  }, {
    key: "on",
    value: function on(event, listener) {
      // Singleton check
      if (!this.subscriptions.get(event)) {
        this.subscriptions.set(event, new Set());
      }
      // Add listener
      var listeners = this.subscriptions.get(event);
      listeners.add(listener);
    }
  }, {
    key: "removeListener",
    value: function removeListener(event, listener) {
      // Remove listener
      var listeners = this.subscriptions.get(event);
      listeners["delete"](listener);
    }
  }]);
  return Emitter;
}();
/* ----------------------- InformedController ----------------------- */
var InformedController = /*#__PURE__*/function () {
  function InformedController() {
    _classCallCheck(this, InformedController);
    this.emitter = new Emitter();

    // Map will store all forms by name
    // Key => name
    // Val => fieldMetaRef
    // Why? so the form knows about field meta
    this.formMap = new Map();

    // For saving values
    this.savedValues = new Map();
    this.getController = this.getController.bind(this);
    this.register = this.register.bind(this);
    this.deregister = this.deregister.bind(this);
  }
  _createClass(InformedController, [{
    key: "register",
    value: function register(name, controller) {
      debug('Register', name, controller);
      // Clear out old controller
      if (this.formMap.get(name)) {
        this.formMap["delete"](name);
      }
      this.formMap.set(name, controller);
      this.emitter.emit(name, '_ALL_');
    }
  }, {
    key: "deregister",
    value: function deregister(name) {
      debug('De-Register', name);
      if (this.formMap.get(name)) {
        this.formMap["delete"](name);
        this.emitter.emit(name, '_ALL_');
      }
    }
  }, {
    key: "getController",
    value: function getController(name) {
      return this.formMap.get(name);
    }
  }, {
    key: "inform",
    value: function inform(name, target) {
      this.emitter.emit(name, target);
    }
  }, {
    key: "getSavedValues",
    value: function getSavedValues(name) {
      return this.savedValues.get(name);
    }
  }, {
    key: "setSavedValues",
    value: function setSavedValues(name, values) {
      return this.savedValues.set(name, values);
    }
  }]);
  return InformedController;
}();
var Informed = function Informed(_ref) {
  var children = _ref.children;
  debug('Render Informed Provider');

  // Create informed controller
  var _useState = useState(function () {
      return new InformedController();
    }),
    _useState2 = _slicedToArray(_useState, 1),
    informedController = _useState2[0];
  return /*#__PURE__*/React.createElement(InformedContext.Provider, {
    value: informedController
  }, children);
};

export { Informed };
